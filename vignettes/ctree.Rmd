---
title: "Примеры"
author: "Juho Härme"
date: "`r Sys.Date()`"
output: 
    html_document:
        dev: svg
---

# Ctree

Демонстрируем на основе тех данных, что у нас есть сейчас. 

```{r}

library(stockholm)

```

В принципе, что важно при ctree и подобных методах - это то, что
мы должны иметь так называемое "response variable" (также называется 
dependent variable, predicted variable.. ну, вам это, наверно, известно):
то есть переменная, на которую (потенциально) влияют другие переменные.
В вашем случае, такой переменной, скорее всего, будет прилагательное,
то есть переменная со следующими категориями:

```{r}

bolshaja$adj  %>% levels

```

Итак, теперь давайте представим себе такую ситуацию, что перед
нами какой-то человек, желающий высказать (или писать) предложение
на русском языке. Мы знаем, что он обращается к какому-то собеседнику.
И еще мы знаем, что в своем предложении он будет использовать
одно из вышеупомянутых прилагательных. Вопрос только -- какое?
Или, точнее, какое из этих четырех прилагательных самый вероятный вариант?


```{r, echo=FALSE}

fr <- bolshaja  %>% count(adj)  %>% arrange(desc(n))

```

Если мы ничего кроме уже упомянутых фактов не знаем, нам бы наверно
стоило опираться на то, какое из прилагательных является самым частотным, и 
мы бы могли сказать, что, зная только то, что человек будет использовать
одно из этих прилагательных при обращении к собеседнику, вероятнее всего
его выбором будет...  *милый*, поскольку это самое частотное в нашем
материале.

Но это пока совсем не полезно. Разумеется, мы хотим определить характеристики
ситуации более подробно и пользоваться всей той информацией, которую мы имеем о
каждой ситуации, где употребляется то или иное из наших прилагательных. Так
что если мы знаем, что в какой-то ситуации человек, выговаривающий предложение с
прилагательным - это мужчина, который это предложение говорит своей жене, то,
наверно, наш "прогноз" о его выборе было бы уже более аккуратное. Подобная информация
у нас представлена в переменной "participants". Иными словами, "participants" 
является независимой переменной (dependent variable / predictor / x variable...),
с помощью которой мы можем более аккуратно делать выводы о том, какое из
четырех возможных прилагательных будет выбрано.
На основе такое информации уже можно построить ctree, так что попробуем.

Сначала, чтобы картинка, которую мы получим в результате функции ctree была
более понятной, я сокращаю названия категории переменной "участники ситуации".
Также сокращаю прилагательные, используя только первую букву:

```{r}

library(dplyr)

tab <- bolshaja  %>% 
    mutate(part = as.factor(paste0(substr(participants,1,4),"")),
           adj=as.factor(substr(adj,1,1)))
```

Вот как теперь выглядит таблица "tab", которую будем далее использовать:

```{r}

tab %>% 
    count(participants, part) %>% 
    arrange(desc(n)) 

```

Ну и в принципе уже можно смотреть на дерево:

```{r, fig.width=20, fig.height=16}

library(party)
set.seed(231344)
derevo1 <- ctree(adj ~ part,data=tab)

plot(derevo1,         
  inner_panel=node_inner(derevo1,
       abbreviate = FALSE,            
       pval = T, 
       id = F),
     terminal_panel=node_barplot(derevo1,id=F,beside=T,ylines=1.2,gap=0,ymax=1))

```


Тут видно, что во-первых алгорифм разделяет данные так, что одну
половину образуют категории `nezn, proc, sniz, sver, znak` и 
другую категории `brat, deti, muzh, nian, rodi, rods, vlub, zver`.
Вполне логично, хотя категория *звери*, наверно, немного мешает..
В чем разница этих двух категорий? Кажется, в основном в том, 
что люди, близкие друг к другу, относительно редко используют
*дорогой*, и относительно часто *милый*. Это разделение статистически
значима, поскольку в нем написано, что p-value меньше чем 0.1.
Далее, алгоритм предлагает и более точные разделения внутри этих двух категорий.
Интересно, например, то, что категории "deti roditeli"
и "niania" попали на той же "конечной ветке", и отличаются в основном тем, что
дети, обращаясь к родителям, иногда употребляют и форму "дорогой".

Все это, наверно, хорошо, но было бы, конечно, важно иметь
и другую дополнительную информацию кроме участников ситуации.
Ведь преимущество таких методов как *ctree* и особенно
*random forests* как раз в том,
что они помогают нам определиться, какие  независимые переменные важнее других.

Насколько я правильно помню, мы недавно добавили категорию "тональность".
Она выглядит вот так:


```{r}

bolshaja %>% count(tonalnost)


```

эта категория немного проблематична, поскольку там так мало случаев с "aggr".
Но в принципе можно попробовать ее тоже добавить в нашу формулу, так что
получится вот так:


```{r, fig.width=20, fig.height=16}

set.seed(231344)

tab <- tab  %>% mutate(tonalnost=as.factor(tonalnost))
derevo2 <- ctree(adj ~ part + tonalnost,data=tab)

plot(derevo2,         
  inner_panel=node_inner(derevo2,
       abbreviate = FALSE,            
       pval = T, 
       id = T),
     terminal_panel=node_barplot(derevo2,id=F,beside=T,ylines=1.2,gap=0,ymax=1))

```

Вот что нам помогает видеть переменная *тональность*: участники ситуации
до сих пор объясняют основную массу случаев но есть один случай (ветка № 7),
где статистически значимую разницу показывает и тональность.
Если мы знаем, что участниками ситуации являются знакомые, то
тогда алгоритм разделяет две группы: если тональность агрессивная, то
тогда очень много употребляют прилагательное *милый*, а если неагрессивная,
то употребляется часто и *дорогой* + иногда *родной.*


Еще можно было бы, конечно, попробовать, например, как 
на выбор прилагательного влияет время публикации источника. Но тут
у нас, насколько я правильно помню, небольшая проблема в том плане,
что есть контексты, где год публикации источника либо не указано,
или указано не совсем правильно. Выглядит эта категория вот так:

```{r}

tab %>% count(year)  %>% arrange(desc(year))  %>% print(n=99)

```

Давайте разделим год источника тоже по категориям, например вот
так:

```{r}

tab2 <- tab %>% 
    filter(year != "?") %>% 
    mutate(year=as.character(year))   %>% 
    mutate(year=as.integer(year)) %>% 
    filter(year>1000)  %>% 
    mutate(period=case_when(
                            year < 1850  ~ "<1850",
                            year >= 1850 & year < 1900 ~ "1850--1900",
                            year >= 1900 & year < 1950 ~ "1900--1950",
                            year >= 1950 & year < 2000 ~ "1950--2000",
                            year >= 2000  ~ ">2000"
                            )) 


```

Вы бы, наверно, могли придумать более обоснованные временные периоды,
но это пока только в качестве примера.  Выглядит эта новая переменная
вот так:

```{r}

tab2  %>% count(period)

```

Добавим к нашей формуле, и посмотрим, какие результаты получим
теперь:


```{r, fig.width=20, fig.height=16}

set.seed(231344)

tab2 <- tab2 %>% mutate(period=as.factor(period), tonalnost=as.factor(tonalnost))
derevo3 <- ctree(adj ~ part + tonalnost + period,data=tab2)

plot(derevo3,         
  inner_panel=node_inner(derevo3,
       abbreviate = FALSE,            
       pval = T, 
       id = T),
     terminal_panel=node_barplot(derevo3,id=F,beside=T,ylines=1.2,gap=0,ymax=1))

```

Ну вот, стало, конечно, трудно интерпретировать картинку.. Но можно сказать, что,
действительно существуют некоторые значимые и логичные разделения, полученные
на основе временного периода. В первую очередь можно сказать, что до 1900 века (ветка № 2)
среди не-самых-близких-друг-к-другу-собеседников эти прилагательные использовали
по-другому чем в 20-ом и 21-ом веках. В основном прилагательное "милый", кажется,
было раньше более широко используемой.

Руководствуясь тем, что Левшина говорит на странице 296 можно, конечно,
попробовать ограничить количество веток, например вот так:


```{r, fig.width=20, fig.height=16}

set.seed(231344)

tab2 <- tab2 %>% mutate(period=as.factor(period), tonalnost=as.factor(tonalnost))
derevo3 <- ctree(adj ~ part + tonalnost + period,data=tab2, 
                controls = ctree_control(testtype = "MonteCarlo", mincriterion = 0.99, minbucket = 15) 
                 )

plot(derevo3,         
  inner_panel=node_inner(derevo3,
       abbreviate = FALSE,            
       pval = T, 
       id = T),
     terminal_panel=node_barplot(derevo3,id=F,beside=T,ylines=1.2,gap=0,ymax=1))

```


# Random forests


Теперь коротко о Random Forests. Это просто значит, что мы запускаем одновременно
очень много таких деревьев которые я выше показал, и на основе такого "леса"
пытаемся определить, какие переменные на самом деле являются важными, а какие
менее важными. Попробуем теми параметрами, которые у нас были в последнем дереве.

**Предупреждение: Следующие команди длятся очень долго**

```{r}

forest <-  cforest(adj ~ part + tonalnost + period,data=tab2, 
                   controls = cforest_unbiased(ntree = 1000, mtry = 2))


```


И, наконец, построим, результаты как показано в  (levshina 298):

```{r}

f.varimp <- varimp(forest,conditional=TRUE)
round(f.varimp, 3)

#dotchart(sort(f.varimp), variables") main = "Conditional Conditional importance of variables 

```

видно, что самое значимое - это участники, но временной период тоже какую-то роль играет.


